
**1. 什么是 Java 虚拟机？为什么 Java 被称作是 “ 平台无关的编程语言 ” ？**

Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。 Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。 
Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。 
Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

**2.JDK 和 JRE 的区别是什么**？

JDK:   java 开发工具包 , 包含了 JRE 、编译器和其它工具（如： javaDOc 、 java 调试器 )
JRE:  java 运行环境 , 包含 java 虚拟机和 java 程序所需的核心类库。 
如果只是想跑 java 程序，那么只需安装 JRE ，如果要写 java 程序并且运行，那就需要 JDK 了。

**3."static" 关键字是什么意思？ Java 中是否可以覆盖一个 private 或者是 static 的方法？**

如果一个类的变量或者方法前面有 static 修饰，那么表明这个方法或者变量属于这个类，也就是说可以在不创建对象的情况下直接使用 
当父类的方法被 private 修饰时，表明该方法为父类私有，对其他任何类都是不可见的，因此如果子类定了一个与父类一样的方法，这对于子类来说相当于是一个新的私有方法，且如果要进行向上转型，然后去调用该 “ 覆盖方法 ” ，会产生编译错误

class Parent {
    private fun() {
        ...
    }   
}
class Child extends Parent {
    private fun() {
        ...
    }
}
class Test {
    public static void main(String[] args) {
        Parent c = new Child();
        c.fun(); //编译出错
    }
}
static 方法时编译时静态绑定的，属于类，而覆盖是运行时动态绑定的 ( 动态绑定的多态 ), 因此不能覆盖 .

**4.Java 支持的基本数据类型有哪些？什么是自动拆装箱？**

java 支持的基本数据类型有以下 9 种 :byte,shot,int,long,float,double,char,boolean,void.
自动拆装箱是 java 从 jdk1.5 引用，目的是将原始类型自动的装换为相对应的对象，也可以逆向进行，即拆箱。这也体现 java 中一切皆对象的宗旨。 
所谓自动装箱就是将原始类型自动的转换为对应的对象，而拆箱就是将对象类型转换为基本类型。 java 中的自动拆装箱通常发生在变量赋值的过程中，如：

    Integer object = 3; //自动装箱
    int o = object; //拆箱
在 java 中，应该注意自动拆装箱，因为有时可能因为 java 自动装箱机制，而导致创建了许多对象，对于内存小的平台会造成压力。

**5. 覆盖和重载是什么 ?**

覆盖 也叫 重写 ，发生在子类与父类之间，表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。 
重载 是指在一个类中，可以有多个相同名称的方法，但是他们的参数列表的个数或类型不同，当调用该方法时，根据传递的参数类型调用对应参数列表的方法。当参数列表相同但返回值不同时，将会出现编译错误，这并不是重载，因为 jvm 无法根据返回值类型来判断应该调用哪个方法。


方法的重写（override）两同两小一大原则：
- 方法名相同，参数类型相同
- 子类返回类型小于等于父类方法返回类型，
- 子类抛出异常小于等于父类方法抛出异常，
- 子类访问权限大于等于父类方法访问权限


**6.Java 支持多继承么？如果不支持，如何实现 ?**

在 java 中是单继承的，也就是说一个类只能继承一个父类。 
java 中实现多继承有两种方式 , 一是接口，而是内部类 .

//实现多个接口 如果两个接口的变量相同 那么在调用该变量的时候 编译出错
interface interface1 {
    static String field = "dd";
    public void fun1();
    }
interface interface2 {
static String field = "dddd";
    public void fun2();
    }
class child implements interface1,interface2 {
    static String field = "dddd";
    @Override
    public void fun2() {
    }
 
    @Override
    public void fun1() {
    }   
}
 
//内部类 间接多继承
class Child {
class Father {
    private void strong() {
        System.out.println("父类");
    }
}
class Mother {
    public void getCute() {
        System.out.println("母亲");
    }
}
public void getStrong() {
    Father f = new Father();
    f.strong();
    }
public void getCute() {
    Mother m = new Mother();
    m.getCute();
    }
}

**7. 什么是值传递和引用传递？ java 中是值传递还是引用传递，还是都有 ?**

值传递   就是在方法调用的时候，实参是将自己的一份拷贝赋给形参，在方法内，对该参数值的修改不影响原来实参，常见的例子就是刚开始学习 c 语言的时候那个交换方法的例子了。 
引用传递   是在方法调用的时候，实参将自己的地址传递给形参，此时方法内对该参数值的改变，就是对该实参的实际操作。 
在 java 中只有一种传递方式，那就是 值传递 . 可能比较让人迷惑的就是 java 中的对象传递时，对形参的改变依然会意向到该对象的内容。 下面这个例子来说明 java 中是值传递 .

    public class Test {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("hello ");
        getString(sb);
        System.out.println(sb);
    }
    public static void getString(StringBuffer s) {
        //s = new StringBuffer("ha");
        s.append("world");
    }
}
在上面这个例子中 , 当前输出结果为 :hello world 。这并没有什么问题，可能就是大家平常所理解的引用传递，那么当然会改变 StringBuffer 的内容。但是如果把上面的注释去掉，那么就会输出 :hello. 此时 sb 的值并没有变成 ha hello. 假如说是引用传递的话，那么形参的 s 也就是 sb 的地址，此时在方法里 new StringBuffer （），并将该对象赋给 s ，也就是说 s 现在指向了这个新创建的对象 . 按照引用传递的说法，此时对 s 的改变就是对 sb 的操作，也就是说 sb 应该也指向新创建的对象，那么输出的结果应该为 ha world. 但实际上输出的仅是 hello. 这说明 sb 指向的还是原来的对象，而形参 s 指向的才是创建的对象 , 这也就验证了 java 中的对象传递也是值传递。

**8. 接口和抽象类的区别是什么 ?**

 不同点在于：

- 1.    接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。

- 2.    类可以实现很多个接口，但是只能继承一个抽象类

- 3.    类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。

- 4.    抽象类可以在不提供接口方法实现的情况下实现接口。

- 5.    Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。

- 6.    Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private ， protected 或者是 public 。

- 7.    接口是绝对抽象的，不可以被实例化 (java 8 已支持在接口中实现默认的方法 ) 。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。


9. 构造器（ constructor ）是否可被重写（ override ） ?

构造方法是不能被子类重写的，但是构造方法可以重载，也就是说一个类可以有多个构造方法。

10.Math.round(11.5) 等于多少 ? Math.round(-11.5) 等于多少 ?

Math.round(11.5)==12 Math.round(-11.5)==-11 round 方法返回与参数 最接近的长整数，参数加 1/2 后求其 floor.

**11. String, StringBuffer StringBuilder 的区别。**

String 的长度是不可变的；

StringBuffer 的长度是可变的，如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer ，如果最后需要 >String ，那么使用 StringBuffer 的 toString() 方法；线程安全；

StringBuilder 是从 JDK 5 开始，为 StringBuffer 该类补充了一个单个线程使用的等价类；通常应该优先使用 StringBuilder 类，因 > 为它支持所有相同的操作，但由于它不执行同步，所以速度更快。 使用字符串的时候要特别小心，如果对一个字符串要经常改变的话，就一定不要用 String, 否则会创建许多无用的对象出来 . 来看一下比较

    String s = "hello"+"world"+"i love you";
    StringBuffer Sb = new StringBuilder("hello").append("world").append("i love you");

这个时候 s 有多个字符串进行拼接，按理来说会有多个对象产生，但是 jvm 会对此进行一个优化，也就是说只创建了一个对象，此时它的执行速度要比 StringBuffer 拼接快 . 再看下面这个 :

    String s2 = "hello"; 
    String s3 = "world"; 
    String s4 = "i love you"; 
    String s1 = s2 + s3 + s4;

上面这种情况，就会多创建出来三个对象，造成了内存空间的浪费 .

**12.JVM 内存分哪几个区，每个区的作用是什么 ?**

**方法区**

- 1. 有时候也成为 永久代 ，在该区内很少发生垃圾回收，但是并不代表不发生 GC ，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载 
- 2. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
- 3. 该区域是被线程共享的。 
- 4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

**虚拟机栈**

- 1. 虚拟机栈也就是我们平常所称的 栈内存 , 它为 java 方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。 
- 2. 虚拟机栈是线程私有的，它的生命周期与线程相同。 
- 3. 局部变量表里存储的是基本数据类型、 returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定 
- 4. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式 
- 5. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接 . 动态链接就是将常量池中的符号引用在运行期转化为直接引用。

**本地方法栈**

本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。

**堆 **

java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。

**程序计数器 **

内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。

**13. 如和判断一个对象是否存活 ?( 或者 GC 对象的判定方法 )**

判断一个对象是否存活有两种方法 :

**1.引用计数法** 

所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是 “ 死对象 ”, 将会被垃圾回收 .
引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B ，对象 B 又引用者对象 A ，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

**2. 可达性算法 ( 引用链法 )**

该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。 
在 java 中可以作为 GC Roots 的对象有以下几种 :

- 虚拟机栈中引用的对象
- 
- · 方法区类静态属性引用的对象
- 
- ·方法区常量池引用的对象
- 
- · 本地方法栈 JNI 引用的对象     

虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比 不一定会被回收 。当一个对象不可达 GC Root 时，这个对象并   不会立马被回收 ，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记 <br/>
如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 <br/>
如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。 GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除 " 即将回收 " 集合，等待回收。<br/>

**14. 简述 java 垃圾回收机制 ?**

在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

**15.java 中垃圾收集的方法有哪些 ?**

**1.标记 - 清除 : **

这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题： 

1- . 效率不高，标记和清除的效率都很低； 
- 2. 2. 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。

**2.复制算法 :** 

为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。 
于是将该算法进行了改进，内存区域不再是按照 1 ： 1 去划分，而是将内存划分为 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。 (java 堆又分为新生代和老年代 )

**3.标记 - 整理 **

该算法主要是为了解决标记 - 清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。 

**4.分代收集 **  

现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用 复制 算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用 标记 - 整理   或者   标记 - 清除 。

**16.java 内存模型**

java 内存模型 (JMM) 是线程间通信的控制机制 .JMM 定义了主内存和线程之间抽象关系。线程之间的共享变量存储在主内存（ main memory ）中，每个线程都有一个私有的本地内存（ local memory ），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 
  
线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤： 

- 1. 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。 
- 2. 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。 
- 写的很好 :http://www.infoq.com/cn/articles/java-memory-model-1

**17.java 类加载过程 ?**

java 类加载需要经历一下 7 个过程： 
**加载 **

加载时类加载的第一个过程，在这个阶段，将完成一下三件事情： 
- 1. 通过一个类的全限定名获取该类的二进制流。 
- 2. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 3. 在内存中生成该类的 Class 对象，作为该类的数据访问入口。

**验证** 

验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机 . 在该阶段主要完成以下四钟验证 :
- 1. 文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型 .
- 2. 元数据验证 : 对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。 
- 3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。 
- 4. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

**准备** 

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。

    public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。

**解析** 

该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

**初始化 **

初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。

**18. 简述 java 类加载机制 ?**

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型。

**19. 类加载器双亲委派模型机制？**

当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

**20. 什么是类加载器，类加载器有哪些 ?**

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。 
主要有一下四种类加载器 :

1- . 启动类加载器 (Bootstrap ClassLoader) 用来加载 java 核心类库，无法被 java 程序直接引用。 
- 2. 扩展类加载器 (extensions class loader): 它用来加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 
- 3. 系统类加载器（ system class loader ）：它根据 Java 应用的类路径（ CLASSPATH ）来加载 Java 类。一般来说， Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。 
- 4. 用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。

**21. 简述 java 内存分配与回收策率以及 Minor GC 和 Major GC**

- 1.    对象优先在堆的 Eden 区分配。
- 2.    大对象直接进入老年代 .
- 3.    长期存活的对象将直接进入老年代 .
 
当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快 <br/>
;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC, 但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。<br/>

**22.HashMap 的工作原理是什么**

HashMap 内部是通过一个数组实现的，只是这个数组比较特殊，数组里存储的元素是一个 Entry 实体 (jdk 8 为 Node) ，这个 Entry 实体主要包含 key 、 value 以及一个指向自身的 next 指针。<br/> 

HashMap 是基于 hashing 实现的，当我们进行 put 操作时，根据传递的 key 值得到它的 hashcode ，然后再用这个 hashcode 与数组的长度进行模运算，得到一个 int 值，就是 Entry 要存储在数组的位置（下标）；<br/>

当通过 get 方法获取指定 key 的值时，会根据这个 key 算出它的 hash 值（数组下标），根据这个 hash 值获取数组下标对应的 Entry ，然后判断 Entry 里的 key ， hash 值或者通过 equals() 比较是否与要查找的相同，如果相同，返回 value ，否则的话，遍历该链表（有可能就只有一个 Entry ，此时直接返回 null ），直到找到为止，否则返回 null 。 <br/>

HashMap 之所以在每个数组元素存储的是一个链表，是为了解决 hash 冲突问题，当两个对象的 hash 值相等时，那么一个位置肯定是放不下两个值的，于是 hashmap 采用链表来解决这种冲突， hash 值相等的两个元素会形成一个链表。<br/>

**23.HashMap 与 HashTable 的区别是什么 ?**

- 1.HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap 。 Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。（在 java 8 中我查看源码发现 Hashtable 并没有继承 Dictionary, 而且里面也没有同步方法，是不是 java 8 中 Hashtable 不在同步的了？有没有人解释一下？） 

- 2. HashMap 的 key 和 value 都允许为 null ，而 Hashtable 的 key 和 value 都不允许为 null 。 HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理，而对 value 没有处理； Hashtable 遇到 null ，直接返回 NullPointerException 。 

- 3. Hashtable 是同步的，而 HashMap 是非同步的，但是我们也可以通过 Collections.synchronizedMap(hashMap), 使其实现同步。

**24.CorrentHashMap 的工作原理 ?**

jdk 1.6 版 :   ConcurrenHashMap 可以说是 HashMap 的升级版， 

- ConcurrentHashMap 是线程安全的，但是与 Hashtablea 相比，实现线程安全的方式不同。 Hashtable 是通过对 hash 表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。 
- ConcurrentHashMap 是采用分离锁的方式，它并没有对整个 hash 表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对 hash 表其他地方的访问。 

**具体实现** :ConcurrentHashMap 内部有一个 Segment<K,V> 数组 , 该 Segment 对象可以充当锁。 Segment 对象内部有一个 HashEntry<K,V> 数组，于是每个 Segment 可以守护若干个桶 (HashEntry), 每个桶又有可能是一个 HashEntry 连接起来的链表，存储发生碰撞的元素。<br/> 
每个 ConcurrentHashMap 在默认并发级下会创建包含 16 个 Segment 对象的数组，每个数组有若干个桶，当我们进行 put 方法时，通过 hash 方法对 key 进行计算，得到 hash 值，找到对应的 segment ，然后对该 segment 进行加锁，然后调用 segment 的 put 方法进行存储操作，此时其他线程就不能访问当前的 segment ，但可以访问其他的 segment 对象，不会发生阻塞等待。<br/>  
jdk 1.8 版   在 jdk 8 中， ConcurrentHashMap 不再使用 Segment 分离锁，而是采用一种乐观锁 CAS 算法来实现同步问题，但其底层还是 “ 数组 + 链表 -> 红黑树 ” 的实现。<br/> 

**25. 遍历一个 List 有哪些不同的方式？**

    List<String> strList = new ArrayList<>();
    //for-each
    for(String str:strList) {
        System.out.print(str);
    }
 
    //use iterator 尽量使用这种 更安全(fail-fast)
    Iterator<String> it = strList.iterator();
    while(it.hasNext) {
        System.out.printf(it.next());
    }
**26.fail-fast 与 fail-safe 有什么区别？**

Iterator 的 fail-fast 属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。 Java.util 包中的所有集合类都被设计为 fail->fast 的，而 java.util.concurrent 中的集合类都为 fail-safe 的。当检测到正在遍历的集合的结构被改变时， Fail-fast 迭代器抛出 ConcurrentModificationException ，而 fail-safe 迭代器从不抛出 ConcurrentModificationException 。

**27.Array 和 ArrayList 有何区别？什么时候更适合用 Array ？**

1.    Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。

2.    Array 是指定大小的，而 ArrayList 大小是固定的

**28. 哪些集合类提供对元素的随机访问？**

ArrayList 、 HashMap 、 TreeMap 和 HashTable 类提供对元素的随机访问。

**29.HashSet 的底层实现是什么 ?**

通过看源码知道 HashSet 的实现是依赖于 HashMap 的， HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象， HashSet 不允许值重复，因此， HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false 。

**30.LinkedHashMap 的实现原理 ?**

LinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header ，这个 header 不是放在 Table 里，它是额外独立出来的。 LinkedHashMap 通过继承 hashMap 中的 Entry, 并添加两个属性 Entry before,after, 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。 LinkedHashMap 定义了排序模式 accessOrder ，该属性为 boolean 型变量，对于访问顺序，为 true ；对于插入顺序，则为 false 。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。

**31.LinkedList 和 ArrayList 的区别是什么 ?**

- 1.    ArrayList 是基于数组实现， LinkedList 是基于链表实现
- 
- 2.    ArrayList 在查找时速度快， LinkedList 在插入与删除时更具优势

**32. 什么是线程？进程和线程的关系是什么？**

线程可定义为进程内的一个执行单位，或者定义为进程内的一个可调度实体。 在具有多线程机制的操作系统中，处理机调度的基本单位不是进程而是线程。一个进程可以有多个线程，而且至少有一个可执行线程。 <br/>
打个比喻 : 进程好比工厂 ( 计算机 ) 里的车间，一个工厂里有多个车间 ( 进程 ) 在运转 , 每个车间里有多个工人（线程）在协同工作，这些工人就可以理解为线程。 

**线程和进程的关系 :**

- 1. 线程是进程的一个组成部分 .
- 2. 进程的多个线程都在进程地址空间活动 .
- 3. 系统资源是分配给进程的，线程需要资源时，系统从进程的资源里分配给线程 .
- 4. 处理机调度的基本单位是线程 .

**33.Thread 类中的 start() 和 run() 方法有什么区别？**

start() 方法被用来启动新创建的线程，而且 start() 内部调用了 run() 方法，这和直接调用 run() 方法的效果不一样。当你调用 run() 方法的时候，只会是在原来的线程中调用，没有新的线程启动， start() 方法才会启动新线程。



**34. 什么是线程安全 ?**

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为。 
线程安全的核心是 “ 正确性 ” ，也就是说当多个线程访问某个类时，能够得到预期的结果，那么就是线程安全的。

**forward/redirect**

- 1.从地址栏显示来说

forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.
redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

- 2.从数据共享来说

 forward:转发页面和转发到的页面可以共享request里面的数据.
 redirect:不能共享数据.
 
- 3.从运用地方来说

 forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
 redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.

- 4.从效率来说

forward:高.
redirect:低.


**鲁棒性(Robust,即健壮性)**
Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生 的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外， Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。



一个java文件可以包含多个java类，但是只能包含一个public类，并且public类的类名必须与java文件名相同


**Java中JDK的各种包**

Java中JDK的各种包的作用：java.lang java.util java.awt javax.swing java.io java.net java.applet 

- java.lang:java的语言包，是一个核心包，系统自动将这个包引入到用户程序，该包中主要的类，object类，它是所有类的父类，其中定义的方法其它类都可以使用。数据类型包装类，数学类，字符串类，系统和运行时类，操作类，线程类，错误和异常处理类，过程类。System提供一个独立于具体计算机资源的编程界面，Runtime类可用于直接访问运行时资源。
- java.util:java的实用包， 实用包提供了各种实用功能的类，主要包括日期类、数据结构类和随机数类等。
-  Java的java.awt提供了绘图和图像类，主要用于编写GUI程序，包括按钮、标签等常用组件以及相应的事件类

**数据比较**

JVM中一个字节以下的整型数据会在JVM启动的时候加载进内存，除非用new Integer()显式的创建对象，否则都是同一个对象<br/>
更加祥细的说明：<br/>

如果是primitive主类型，那么比较值；如果是对象，那么比较引用地址<br/>
equals需要根据具体对象的实现来判断，在Integer里面是判断值是否相等<br/>

一般说来，如果是两个Integer类型进行=比较，就是比较两个Integer对象的地址。但是有一点需要注意的是在-128至127这个区间，如果创建Integer对象的时候<br/>

- （1）Integer i = 1; 
- （2） Integer i = Integer.valueOf(1); 

如果是这两种情况创建出来的对象，那么其实只会创建一个对象，这些对象已经缓存在一个叫做IntegerCache里面了，所以==比较是相等的。<br/>
如果不在-128至127这个区间，不管是通过什么方式创建出来的对象，==永远是false，也就是说他们的地址永远不会相等。<br/>


**Java程序的种类有**：

（a）内嵌于Web文件中，由浏览器来观看的_Applet
（b）可独立运行的 Application
（c）服务器端的 Servlets

**equals**

equals没重写时候和==一样，比较的是对象的地址，题中new 了两个对象，所以各自地址不一样，使用equals比较为false，但是string类型中的equals方法Java默认重写了，可以比较对象里的值；两个对象指向的同一个string成员变量里的值相同，所以eqauals比较也相同


- A，Vector相当于一个线程安全的List
- B，HashMap是非线程安全的，其对应的线程安全类是HashTable
- C，Arraylist是非线程安全的，其对应的线程安全类是Vector
- D，StringBuffer是线程安全的，相当于一个线程安全的StringBuilder
- E，Properties实现了Map接口，是线程安全的

**volatile**
出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。




**- Collection**

-     -----List<br/>
-                -----LinkedList    非同步<br/>
-                 ----ArrayList      非同步，实现了可变大小的元素数组<br/>
-                 ----Vector          同步<br/>
-                       ------Stack<br/>
-                 ----Set   不允许有相同的元素<br/>

**- Map**

-     -----HashTable        同步，实现一个key--value映射的哈希表<br/>
-     -----HashMap          非同步，<br/>
-     -----WeakHashMap   改进的HashMap，实现了“弱引用”，如果一个key不被引用，则被GC回收<br/>


**final**

- final修饰的方法，不允许被子类覆盖。
- final修饰的类，不能被继承。
- final修饰的变量，不能改变值。
- 使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。


** 虚拟机的功能 **

- （1）通过 ClassLoader 寻找和装载 class 文件
- （2）解释字节码成为指令并执行，提供 class 文件的运行环境
- （3）进行运行期间垃圾回收
- （4）提供与硬件交互的平


**Throwable的子类： **

- 1.Exception（异常） :是程序本身可以处理的异常。 
- 2.Error（错误）: 是程序无法处理的错误。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，一般不需要程序处理。
- 3.检查异常（编译器要求必须处置的异常） ：  除了Error，RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。
- 4.非检查异常(编译器不要求处置的异常): 包括运行时异常（RuntimeException与其子类）和错误（Error）
- 

**关键字**

 java中true ,false ,null在java中不是关键字，也不是保留字，它们只是显式常量值，但是你在程序中不能使用它们作为标识符。<br/>
其中const和goto是java的保留字。java中所有的关键字都是小写的，还有要注意true,false,null,　friendly，sizeof不是java的关键字,但是你不能把它们作为java标识符用。<br/>



**多线程一共有三种实现方式**

- 1.class A继承Thread，并重写run方法，new A().start()，就执行了线程
- 2.class A实现Runnable，实现run方法，new Thread(new A()).start()

当然以上方式run方法都是无返回值的，如果需要返回值，需要Callable接口,但是该方式是依赖于线程池的。。


**五个基本原则： **

- 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。
  
- 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 

- Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

- 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。

- 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口
 

**成员方法和静态方法:**

成员方法又称为实例方法<br/>
静态方法又称为类方法<br/>
其次：<br/>

- a，静态方法中没有this指针
- c，可以通过类名作用域的方式调用Class::fun();
- d，在类中申请一个类对象或者参数传递一个对象或者指针都可以调用;


**基本类型**

java语言是强类型语言，支持的类型分为两类：基本类型和引用类型。<br/>
基本类型包括boolean类型和数值类型，数值类型有整数类型和浮点类型。整数类型包括：byte、short、int、long和char；浮点类型包括：float和double<br/>
引用类型包括类、接口和数组类型以及特殊的null类型。<br/>


**抽象类和接口**

- 1. 一个子类只能继承一个抽象类,但能实现多个接口
- 2. 抽象类可以有构造方法,接口没有构造方法
- 3. 抽象类可以有普通成员变量,接口没有普通成员变量
- 4. 抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意,接口只能public static final(默认)
- 5. 抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法
- 6. 抽象类可以有静态方法,接口不能有静态方法
- 7. 抽象类中的方法可以是public、protected;接口方法只有public


**文件操作：**

- FileInputStream提供了对文件的字节读取；
- FileReader提供了对文件的字符读取；
- FileWriter提供了对文件的字符写入；
- File提供了对文件的基本操作，包括对删除，文件路径等操作。



- ArrayList list=new ArrayList();   这种是默认创建大小为10的数组，每次扩容大小为1.5倍
- ArrayList list=new ArrayList(20);  这种是指定数组大小的创建，没有扩充



- Collection是单列集合的顶层接口,Map是双列集合的顶层接口
- Collections是一个集合的工具类，提供了排序、查找等操作集合的一些常用方法






**Servlet的生命周期一般可以用三个方法来表示：**

- init()：仅执行一次，负责在装载Servlet时初始化Servlet对象
- service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。
- destory()：在停止并且卸载Servlet时执行，负责释放资源

初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建
基本功能：service方法是在servlet生命周期中的服务期，根据HTTP请求方法（GET、POST等），将请求分发到doGet、doPost等方法

实现：默认在HttpServlet类中实现



**Java反射机制**主要提供了以下功能： 

- 在运行时判断任意一个对象所属的类；
- 在运行时构造任意一个类的对象；
- 在运行时判断任意一个类所具有的成员变量和方法；
- 在运行时调用任意一个对象的方法；生成动态代理。

**servlet**

servlet在多线程下其本身并不是线程安全的。<br/>
如果在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误。最好是在方法中，定义局部变量，而不是类变量或者对象的成员变量。由于方法中的局部变量是在栈中，彼此各自都拥有独立的运行空间而不会互相干扰，因此才做到线程安全。<br/>





**内部类**

内部类其实和类的属性没什么区别，只是在声明的时候必须是Outer.Inner a，就像int a 一样，至于静态内部类和非静态内部类new的时候有点区别，Outer.Inner a=new Outer().new Inner()（非静态，先有Outer对象才能有属性） Outer.Inner a=new Outer.Inner()要把Outer.Inner看成一部分，就像类变量一样




**Vector & ArrayList 的主要区别 **

- 1） 同步性:Vector是线程安全的，也就是说是同步的 ，而ArrayList 是线程序不安全的，不是同步的 数2。 
- 2）数据增长:当需要增长时,Vector默认增长为原来一倍 ，而ArrayList却是原来的50%  ，这样,ArrayList就有利于节约内存空间。 

如果涉及到堆栈，队列等操作，应该考虑用Vector，如果需要快速随机访问元素，应该使用ArrayList 。

**扩展知识：**

**1. Hashtable & HashMap **

Hashtable和HashMap它们的性能方面的比较类似 Vector和ArrayList，比如Hashtable的方法是同步的,而HashMap的不是。<br/>

**2. ArrayList & LinkedList**<br/>
ArrayList的内部实现是基于内部数组Object[],所以从概念上讲,它更象数组，但LinkedList的内部实现是基于一组连接的记录，所以，它更象一个链表结构，所以，它们在性能上有很大的差别：   <br/>
从上面的分析可知,在ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间<br/>
所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能； <br/>
而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止<br/>
所以,当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。<br/>
       

-  初始化父类中的静态成员变量和静态代码块 ； 
- 初始化子类中的静态成员变量和静态代码块 ； 
-初始化父类的普通成员变量和代码块，再执行父类的构造方法；
- 初始化子类的普通成员变量和代码块，再执行子类的构造方法； 


switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持。




**锁**

截止JDK1.8版本,java并发框架支持锁包括读写锁自旋锁乐观锁


CGI不可移植，为某一特定平台编写的CGI应用只能运行于这一环境中。每一个CGI应用存在于一个由客户端请求激活的进程中，并且在请求被服务后被卸载。这种模式将引起很高的内存、CPU开销，而且在同一进程中不能服务多个客户。





**SpringMVC的原理：**

SpringMVC是Spring中的模块，它实现了mvc设计模式的web框架，首先用户发出请求，请求到达SpringMVC的前端控制器（DispatcherServlet）,前端控制器根据用户的url请求处理器映射器查找匹配该url的handler，并返回一个执行链，前端控制器再请求处理器适配器调用相应的handler进行处理并返回给前端控制器一个modelAndView，前端控制器再请求视图解析器对返回的逻辑视图进行解析，最后前端控制器将返回的视图进行渲染并把数据装入到request域，返回给用户。

DispatcherServlet作为springMVC的前端控制器，负责接收用户的请求并根据用户的请求返回相应的视图给用户。

实现业务操作时在service层



**三个基本元素：**

- 1. 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 
- 2. 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。  
- 3. 多态： 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。

C++ 中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术， RTTI 技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。



**super**

子类的构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。<br/>
super代表父类对应的对象，所以用super访问在子类中无法直接使用的父类成员和方法



